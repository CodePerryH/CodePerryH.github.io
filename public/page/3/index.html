<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="ios">
<meta property="og:type" content="website">
<meta property="og:title" content="须知少时凌云志，曾许人间第一流">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="须知少时凌云志，曾许人间第一流">
<meta property="og:description" content="ios">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="CodeoPerryH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>须知少时凌云志，曾许人间第一流</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">须知少时凌云志，曾许人间第一流</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">iOSer,life,and Cat</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/06/GCD%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headerimage.jpeg">
      <meta itemprop="name" content="CodeoPerryH">
      <meta itemprop="description" content="ios">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="须知少时凌云志，曾许人间第一流">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/06/GCD%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9/" class="post-title-link" itemprop="url">GCD</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-06 17:19:03" itemprop="dateCreated datePublished" datetime="2018-08-06T17:19:03+08:00">2018-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-27 14:28:43" itemprop="dateModified" datetime="2022-01-27T14:28:43+08:00">2022-01-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<p>GCD在iOS中应该是最常使用的并发编程技术了，GCD接口设计得很简洁，使用起来也很方便，由于苹果做了高度的封装，所以很多人对GCD的原理并不是很了解，本文来总结一下GCD常用面试要点。</p>
<h1 id="什么是GCD"><a href="#什么是GCD" class="headerlink" title="什么是GCD"></a>什么是GCD</h1><p>GCD(Grand Central Dispatch) 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。</p>
<h1 id="队列和任务"><a href="#队列和任务" class="headerlink" title="队列和任务"></a>队列和任务</h1><p>GCD中有两个核心概念，队列和任务。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列其实就是线程池，在OC中以dispatch_queue_t表示，队列分串行队列和并发队列。</p>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>任务其实就是线程执行的代码，在OC中以Block表示。<br>在队列中执行任务有两种方式：同步执行和异步执行。两者的主要区别是：是否等待队列的任务执行结束，以及是否具备创建新线程的能力。</p>
<ul>
<li>同步执行（sync）：<br>  1、同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。<br>  2、只能在当前线程中执行任务，不会创建新线程。</li>
<li>异步执行（async）：<br>  1、异步添加任务到指定的队列中，添加完成可以继续执行后面的代码。<br>  2、可以在新的线程中执行任务，可能会创建新线程。</li>
</ul>
<h1 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h1><h2 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h2><p>用dispatch_queue_create来创建队列,其中第一个参数label表示队列的名称，可以为NULL；第二个参数attr用来表示创建串行队列还是并发队列，DISPATCH_QUEUE_SERIAL 或者NULL表示串行队列，DISPATCH_QUEUE_CONCURRENT 表示并发队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t dispatch_queue_create(const char *_Nullable label, dispatch_queue_attr_t _Nullable attr);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="主队列和全局队列"><a href="#主队列和全局队列" class="headerlink" title="主队列和全局队列"></a>主队列和全局队列</h2><p>主队列：主队列是串行队列，只有一个线程，那就是主线程，添加到主队列中的任务会在主线执行。通过dispatch_get_main_queue获取主队列。<br>全局队列：全局队列是并发队列。可以通过dispatch_get_global_queue获取不同级别的全局队列</p>
<h2 id="如何判断当前代码运行在某个队列"><a href="#如何判断当前代码运行在某个队列" class="headerlink" title="如何判断当前代码运行在某个队列"></a>如何判断当前代码运行在某个队列</h2><p>通过队列的label来判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">self.opQueue = dispatch_queue_create(NSStringFromClass([self class]).UTF8String, DISPATCH_QUEUE_SERIAL); //创建一个opQueue，名字为类名。注意：通过类名来创建一个唯一的队列名，因为OC类名不能重复</span><br><span class="line">//下面的方法用来判断当前是否在opQueue</span><br><span class="line">- (BOOL)_isInOpQueue&#123;</span><br><span class="line"></span><br><span class="line">    NSString* currentQueueLabel = [NSString stringWithUTF8String:dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL)];</span><br><span class="line">    if ([currentQueueLabel isEqualToString:NSStringFromClass([self class])]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="同步任务、异步任务"><a href="#同步任务、异步任务" class="headerlink" title="同步任务、异步任务"></a>同步任务、异步任务</h1><h2 id="dispatch-sync和dispatch-async"><a href="#dispatch-sync和dispatch-async" class="headerlink" title="dispatch_sync和dispatch_async"></a>dispatch_sync和dispatch_async</h2><p>用dispatch_sync来创建同步任务<br>用dispatch_async来创建异步任务<br>『主线程』中，『不同队列』+<strong>『不同任务』</strong>简单组合的区别：<br><img src="https://upload-images.jianshu.io/upload_images/22877992-cf988fe2ddcc0277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>『不同队列』+『不同任务』 组合，以及 『队列中嵌套队列』 使用的区别：<br><img src="https://upload-images.jianshu.io/upload_images/22877992-adaafb7855899a53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="同步任务，异步任务线程创建机制"><a href="#同步任务，异步任务线程创建机制" class="headerlink" title="同步任务，异步任务线程创建机制"></a>同步任务，异步任务线程创建机制</h2><h3 id="同步任务-并发队列"><a href="#同步任务-并发队列" class="headerlink" title="同步任务+并发队列"></a>同步任务+并发队列</h3><p>在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务 。执行如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)syncTaskInConcurrentQueue &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    NSLog(@&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(NSStringFromClass([self class]).UTF8String, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:1];</span><br><span class="line">        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:1];</span><br><span class="line">        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运行结果如下：</span><br><span class="line">2020-11-12 00:18:10.088131+0800 OCTestDemo[3337:38026] currentThread---&lt;NSThread: 0x6000020ee880&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-11-12 00:18:10.088254+0800 OCTestDemo[3337:38026] begin</span><br><span class="line">2020-11-12 00:18:11.089673+0800 OCTestDemo[3337:38026] 1---&lt;NSThread: 0x6000020ee880&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-11-12 00:18:12.090277+0800 OCTestDemo[3337:38026] 2---&lt;NSThread: 0x6000020ee880&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-11-12 00:18:12.090526+0800 OCTestDemo[3337:38026] end</span><br><span class="line">可以看到，dispatch_sync调用前运行在主线程，dispatch_sync添加的两个同步任务依次执行并且都运行在主线程，end最后打印，因为要等两个同步任务执行完才能执行后面的代码。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="异步任务-并发队列"><a href="#异步任务-并发队列" class="headerlink" title="异步任务+并发队列"></a>异步任务+并发队列</h3><p>特点：可以开启多个线程，任务并发执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)asyncTaskInConcurrentQueue &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  </span><br><span class="line">    NSLog(@&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(NSStringFromClass([self class]).UTF8String, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运行结果如下：</span><br><span class="line">2020-11-12 00:24:55.171031+0800 OCTestDemo[3458:40785] currentThread---&lt;NSThread: 0x60000126d340&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-11-12 00:24:55.171137+0800 OCTestDemo[3458:40785] begin</span><br><span class="line">2020-11-12 00:24:55.171260+0800 OCTestDemo[3458:40785] end</span><br><span class="line">2020-11-12 00:24:57.176777+0800 OCTestDemo[3458:40829] 1---&lt;NSThread: 0x6000012341c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2020-11-12 00:24:57.176782+0800 OCTestDemo[3458:40831] 2---&lt;NSThread: 0x6000012495c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">可以看到先打印了end，因为这两个任务是异步任务，调用dispatch_async不会阻塞主线程，可以继续执行后面的代码，所以先打印了end。然后再在两个不同的线程并发执行了这两个任务。注意：现执行任务1还是任务2是不确定的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="同步任务-串行队列"><a href="#同步任务-串行队列" class="headerlink" title="同步任务+串行队列"></a>同步任务+串行队列</h3><p>特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)syncTaskInSerialQueue &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  </span><br><span class="line">    NSLog(@&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(NSStringFromClass([self class]).UTF8String, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务 2</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">运行结果如下：</span><br><span class="line">2020-11-12 00:35:08.546658+0800 OCTestDemo[3548:44335] currentThread---&lt;NSThread: 0x600002555340&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-11-12 00:35:08.546789+0800 OCTestDemo[3548:44335] begin</span><br><span class="line">2020-11-12 00:35:10.547507+0800 OCTestDemo[3548:44335] 1---&lt;NSThread: 0x600002555340&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-11-12 00:35:12.548172+0800 OCTestDemo[3548:44335] 2---&lt;NSThread: 0x600002555340&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-11-12 00:35:12.548399+0800 OCTestDemo[3548:44335] end</span><br><span class="line"></span><br><span class="line">可以看到任务1和任务2是运行在主线程，因为队列是串行队列，所以任务1和任务2先后执行；因为任务1和2都是同步任务，所以等两个任务完成后才会打印end。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="异步任务-串行队列"><a href="#异步任务-串行队列" class="headerlink" title="异步任务+串行队列"></a>异步任务+串行队列</h3><p>特点：会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)asyncTaskInSerialQueue &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    NSLog(@&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(NSStringFromClass([self class]).UTF8String, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务 1</span><br><span class="line">        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务 2</span><br><span class="line">        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运行结果如下：</span><br><span class="line">2020-11-12 00:44:22.643590+0800 OCTestDemo[3645:47865] currentThread---&lt;NSThread: 0x600003b2e900&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-11-12 00:44:22.643760+0800 OCTestDemo[3645:47865] begin</span><br><span class="line">2020-11-12 00:44:22.643903+0800 OCTestDemo[3645:47865] end</span><br><span class="line">2020-11-12 00:44:24.647874+0800 OCTestDemo[3645:47912] 1---&lt;NSThread: 0x600003b448c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2020-11-12 00:44:26.651177+0800 OCTestDemo[3645:47912] 2---&lt;NSThread: 0x600003b448c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">可以看到先打印了end，然后再串行执行了任务1和任务2，任务1和任务2执行在一个新线程。因为串行队列只会创建一个线程。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="同步任务-主队列"><a href="#同步任务-主队列" class="headerlink" title="同步任务+主队列"></a>同步任务+主队列</h3><h4 id="在主线程中调用-『同步任务-主队列列』"><a href="#在主线程中调用-『同步任务-主队列列』" class="headerlink" title="在主线程中调用 『同步任务+主队列列』"></a>在主线程中调用 『同步任务+主队列列』</h4><p>因为死锁导致crash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)syncTaskInMainQueue &#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    NSLog(@&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">运行后发现打印完成begin后直接crash了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/22877992-56436e5065d81b4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h4 id="在其他线程中调用『同步任务-主队列』"><a href="#在其他线程中调用『同步任务-主队列』" class="headerlink" title="在其他线程中调用『同步任务+主队列』"></a>在其他线程中调用『同步任务+主队列』</h4><p>不会开启新线程，执行完一个任务，再执行下一个任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[NSThread detachNewThreadSelector:@selector(syncTaskInMainQueue) toTarget:self withObject:nil];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运行结果如下：</span><br><span class="line">2020-11-12 00:56:57.272195+0800 OCTestDemo[3782:53141] currentThread---&lt;NSThread: 0x600001ab5080&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2020-11-12 00:56:57.272856+0800 OCTestDemo[3782:53141] begin</span><br><span class="line">2020-11-12 00:56:59.292677+0800 OCTestDemo[3782:53087] 1---&lt;NSThread: 0x600001afcf80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-11-12 00:57:01.294829+0800 OCTestDemo[3782:53087] 2---&lt;NSThread: 0x600001afcf80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-11-12 00:57:01.295815+0800 OCTestDemo[3782:53141] end</span><br><span class="line">可以看到任务1和任务2先后在主线程执行，并且要等任务1和任务2执行完后才会打印end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="异步任务-主队列"><a href="#异步任务-主队列" class="headerlink" title="异步任务+主队列"></a>异步任务+主队列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)asyncTaskInMainQueue &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    NSLog(@&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运行结果如下：</span><br><span class="line">2020-11-12 01:03:02.820131+0800 OCTestDemo[3836:55469] currentThread---&lt;NSThread: 0x600001302640&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-11-12 01:03:02.820307+0800 OCTestDemo[3836:55469] begin</span><br><span class="line">2020-11-12 01:03:02.820435+0800 OCTestDemo[3836:55469] end</span><br><span class="line">2020-11-12 01:03:04.835759+0800 OCTestDemo[3836:55469] 1---&lt;NSThread: 0x600001302640&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-11-12 01:03:06.837321+0800 OCTestDemo[3836:55469] 2---&lt;NSThread: 0x600001302640&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">可以看到在打印完end后，依次在主线程执行任务1和任务2，这是因为任务1和任务2是异步线程并且主队列是串行队列</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="GCD线程池"><a href="#GCD线程池" class="headerlink" title="GCD线程池"></a>GCD线程池</h1><p><img src="https://upload-images.jianshu.io/upload_images/22877992-6172b0a6ba2c1384.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="有几个root队列？"><a href="#有几个root队列？" class="headerlink" title="有几个root队列？"></a>有几个root队列？</h2><p>12个。</p>
<ul>
<li>userInteractive、default、unspecified、userInitiated、utility 6个，他们的overcommit版本6个。<br>  支持overcommit的队列在创建队列时无论系统是否有足够的资源都会重新开一个线程。<br>  串行队列和主队列是overcommit的，创建队列会创建1个新的线程。并行队列是非overcommit的，不一定会新建线程，会从线程池中的64个线程中获取并使用。</li>
<li>  优先级 userInteractive&gt;default&gt;unspecified&gt;userInitiated&gt;utility&gt;background</li>
<li>  全局队列是root队列。</li>
</ul>
<h2 id="有几个线程池？"><a href="#有几个线程池？" class="headerlink" title="有几个线程池？"></a>有几个线程池？</h2><p>两个。一个是主线程池，另一个是除了主线程池之外的线程池。</p>
<h2 id="一个队列最多支持几个线程同时工作？"><a href="#一个队列最多支持几个线程同时工作？" class="headerlink" title="一个队列最多支持几个线程同时工作？"></a>一个队列最多支持几个线程同时工作？</h2><p>64个</p>
<h2 id="多个队列，允许最多几个线程同时工作？"><a href="#多个队列，允许最多几个线程同时工作？" class="headerlink" title="多个队列，允许最多几个线程同时工作？"></a>多个队列，允许最多几个线程同时工作？</h2><p>64个。优先级高的队列获得的可活跃线程数多于优先级低的，但也有例外，低优先级的也能获得少量活跃线程。<br>参考资料：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kenshincui/p/13272517.html">iOS刨根问底-深入理解GCD</a></p>
<h1 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h1><p>可以用disaptch_once来执行一次性的初始化代码，比如创建单例，这个方法是线程安全的。</p>
<h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>用disaptch_once创建单例的时候，如果出现循环引用的情况，会造成死锁。比如A-&gt;B-&gt;C-&gt;A这种调用就会死锁。<br>可以参考<a target="_blank" rel="noopener" href="https://satanwoo.github.io/2016/04/11/dispatch-once/">滥用单例之dispatch_once死锁</a></p>
<h1 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h1><p>用来延迟执行代码。类似NSTimer。需要注意的是：dispatch_after 方法并不是在指定时间之后才开始执行任务，而是在指定时间之后将任务追加到主队列中。</p>
<h1 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a>dispatch_group</h1><p>可以用dispatch_group来实现类似需求，当一组任务都执行完成后，然后再来执行最后的操作。比如进入一个页面同时发起两个网络请求，等两个网络请求都返回后再执行界面刷新。可以用dispatch_group + dispatch_group_enter + dispatch_group_leave + dispatch_group_notify来实现。</p>
<h1 id="dispatch-semaphore-t"><a href="#dispatch-semaphore-t" class="headerlink" title="dispatch_semaphore_t"></a>dispatch_semaphore_t</h1><h2 id="用来计数"><a href="#用来计数" class="headerlink" title="用来计数"></a>用来计数</h2><p>当创建信号量时初始化大于1，可以用来实现多线程并发。</p>
<h2 id="用做锁，效率比较高"><a href="#用做锁，效率比较高" class="headerlink" title="用做锁，效率比较高"></a>用做锁，效率比较高</h2><p>当创建信号量时初始化等于1，退化为锁。信号量锁的效率很高，仅次于OSSpinLock和os_unfair_lock。关于多线程同步可以见笔者另外一篇文章多线程面试要点。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/05/RunLoop%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headerimage.jpeg">
      <meta itemprop="name" content="CodeoPerryH">
      <meta itemprop="description" content="ios">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="须知少时凌云志，曾许人间第一流">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/05/RunLoop%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9/" class="post-title-link" itemprop="url">RunLoop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-05 17:19:03" itemprop="dateCreated datePublished" datetime="2018-08-05T17:19:03+08:00">2018-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-27 14:29:04" itemprop="dateModified" datetime="2022-01-27T14:29:04+08:00">2022-01-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h1 id="RunLoop定义"><a href="#RunLoop定义" class="headerlink" title="RunLoop定义"></a>RunLoop定义</h1><p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">苹果官方文档</a>对RunLoop的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Run loops are part of the fundamental infrastructure associated with threads. A run loop is an event processing loop that you use to schedule work and coordinate the receipt of incoming events. The purpose of a run loop is to keep your thread busy when there is work to do and put your thread to sleep when there is none.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>翻译为中文为：RunLoop是线程基础设施的一部分。RunLoop是iOS中用来接受事件、处理事件的循环。设计RunLoop的目的是让线程有事件的时候处理事件，没事件的时候处于休眠。<br>在iOS中RunLoop实际上是一个对象(CFRunLoopRef 和NSRunLoop)，RunLoop做的事情是处于等待消息-&gt;接受消息-&gt;处理消息这样一个循环中，直到退出循环。</p>
<h1 id="RunLoop原理"><a href="#RunLoop原理" class="headerlink" title="RunLoop原理"></a>RunLoop原理</h1><p>苹果官方原理图<br><img src="https://upload-images.jianshu.io/upload_images/22877992-6a1e5d60f9d891ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>从图中可以看出，RunLoop运行在线程中，接收Input Source 和 Timer Source并且进行处理。</p>
<h2 id="Input-Source-和-Timer-Source"><a href="#Input-Source-和-Timer-Source" class="headerlink" title="Input Source 和 Timer Source"></a>Input Source 和 Timer Source</h2><p>两个都是 Runloop 事件的来源。<br>Input Source 可以分为三类</p>
<ul>
<li>  Port-Based Sources，系统底层的 Port 事件，例如 CFSocketRef ；</li>
<li>  Custom Input Sources，用户手动创建的 Source;</li>
<li>Cocoa Perform Selector Sources， Cocoa 提供的 performSelector 系列方法，也是一种事件源;<br>  Timer Source指定时器事件，该事件的优先级是最低的。<br>  按照上面的图，事件处理优先级是Port &gt; Custom &gt; performSelector &gt; Timer。<br>  Input Source异步投递事件到线程中，Timer Source同步投递事件到线程中。</li>
</ul>
<h2 id="获取RunLoop"><a href="#获取RunLoop" class="headerlink" title="获取RunLoop"></a>获取RunLoop</h2><p>RunLoop是由线程创建的，我们只能获取。通过CFRunLoopGetCurrent获取当前线程的RunLoop，子线程的RunLoop在子线程中第一次调用CFRunLoopGetCurrent创建，主线程的RunLoop在整个App第一次调用CFRunLoopGetCurrent创建，由UIApplication 的run方法调用。</p>
<h2 id="RunLoop与线程关系"><a href="#RunLoop与线程关系" class="headerlink" title="RunLoop与线程关系"></a>RunLoop与线程关系</h2><p>RunLoop与线程是一一对应关系，一个线程对应一个RunLoop，他们的映射存储在一个字典里，key为线程，value为RunLoop。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>CFRunLoop系列函数是线程安全的。NSRunLoop系列函数不是线程安全的。</p>
<h2 id="启动RunLoop"><a href="#启动RunLoop" class="headerlink" title="启动RunLoop"></a>启动RunLoop</h2><p>通过CFRunLoopRun系列函数启动RunLoop，启动时可以指定超时时间。RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，你可以添加一个一次性timer到RunLoop然后再调用CFRunLoopRun。</p>
<h2 id="退出RunLoop"><a href="#退出RunLoop" class="headerlink" title="退出RunLoop"></a>退出RunLoop</h2><ul>
<li>  启动RunLoop时制定超时时间</li>
<li>  通过 CFRunLoopStop主动退出</li>
</ul>
<h2 id="RunLoop-Mode"><a href="#RunLoop-Mode" class="headerlink" title="RunLoop Mode"></a>RunLoop Mode</h2><p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。<br>苹果定义的Mode如下图，其中NSDefaultRunLoopMode、NSEventTrackingRunLoopMode、NSRunLoopCommonModes我们经常会用到。<br><img src="https://upload-images.jianshu.io/upload_images/22877992-e5391b29f7e3eea6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>Source有两种类型：Source0 和 Source1。</p>
<ul>
<li>  Source0 （非基于port）只包含了一个回调，需要手动触发。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li>
<li>  Source1 （基于port），可以主动触发。包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。</li>
</ul>
<h2 id="RunLoop-Observers"><a href="#RunLoop-Observers" class="headerlink" title="RunLoop Observers"></a>RunLoop Observers</h2><p>通过CFRunLoopAddObserver监控RunLoop的状态。RunLoop的状态如下：<br>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {<br>kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop<br>kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer<br>kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source<br>kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠<br>kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒，但是还没完全处理完事件<br>kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop<br>};</p>
<p>我们可以通过Observer来监控主线程的卡顿。</p>
<h2 id="RunLoop处理事件顺序"><a href="#RunLoop处理事件顺序" class="headerlink" title="RunLoop处理事件顺序"></a>RunLoop处理事件顺序</h2><p><img src="https://upload-images.jianshu.io/upload_images/22877992-d3c030c8617ee1a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>RunLoop内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。RunLoop t通过调用mach_msg函数进入休眠等待唤醒状态。</p>
<h1 id="RunLoop应用"><a href="#RunLoop应用" class="headerlink" title="RunLoop应用"></a>RunLoop应用</h1><h2 id="苹果用RunLoop实现的功能"><a href="#苹果用RunLoop实现的功能" class="headerlink" title="苹果用RunLoop实现的功能"></a>苹果用RunLoop实现的功能</h2><p>AutoreleasePool、事件响应、手势识别、界面更新、定时器、PerformSelecter、GCD、网络请求底层等都用到了RunLoop</p>
<h2 id="解决NSTimer事件在列表滚动时不执行问题"><a href="#解决NSTimer事件在列表滚动时不执行问题" class="headerlink" title="解决NSTimer事件在列表滚动时不执行问题"></a>解决NSTimer事件在列表滚动时不执行问题</h2><p>因为定时器默认是运行在NSDefaultRunLoopMode，在列表滚动时候，主线程会切换到UITrackingRunLoopMode，导致定时器回调得不到执行。<br>有两种解决方案：</p>
<ul>
<li>  指定NSTimer运行于 NSRunLoopCommonModes下。</li>
<li>  在子线程创建和处理Timer事件，然后在主线程更新 UI。</li>
</ul>
<h2 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h2><h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><p>在 ARC 下，我们不需要手动管理内存，可以完全不知道 autorelease 的存在，就可以正确管理好内存，因为 Runloop 在每个 Runloop Circle 中会自动创建和释放Autorelease Pool。<br>当我们需要创建和销毁大量的对象时，使用手动创建的 autoreleasepool 可以有效的避免内存峰值的出现。因为如果不手动创建的话，外层系统创建的 pool 会在整个 Runloop Circle 结束之后才进行 drain，手动创建的话，会在 block 结束之后就进行 drain 操作，比如下面例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 100000; i++)</span><br><span class="line">&#123;</span><br><span class="line">    @autoreleasepool</span><br><span class="line">    &#123;</span><br><span class="line">        NSString* string = @&quot;akon&quot;;</span><br><span class="line">        NSArray* array = [string componentsSeparatedByString:string];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比如SDWebImage中这段代码，由于encodedDataWithImage会把image解码成data，可能造成内存暴涨，所以加autoreleasepool避免内存暴涨</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> @autoreleasepool &#123;</span><br><span class="line">    NSData *data = imageData;</span><br><span class="line">    if (!data &amp;&amp; image) &#123;</span><br><span class="line">                    // If we do not have any data to detect image format, check whether it contains alpha channel to use PNG or JPEG format</span><br><span class="line">        SDImageFormat format;</span><br><span class="line">        if ([SDImageCoderHelper CGImageContainsAlpha:image.CGImage]) &#123;</span><br><span class="line">            format = SDImageFormatPNG;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            format = SDImageFormatJPEG;</span><br><span class="line">        &#125;</span><br><span class="line">        data = [[SDImageCodersManager sharedManager] encodedDataWithImage:image format:format options:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    [self _storeImageDataToDisk:data forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Runloop中自动释放池创建和释放时机"><a href="#Runloop中自动释放池创建和释放时机" class="headerlink" title="Runloop中自动释放池创建和释放时机"></a>Runloop中自动释放池创建和释放时机</h3><p>苹果官方文档：</p>
<blockquote>
<p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event</p>
</blockquote>
<p>-系统在Runloop开始处理一个事件时创建一个autoreleaspool。</p>
<ul>
<li>  系统会在处理完一个事件后释放 autoreleaspool 。</li>
<li>我们手动创建的 autoreleasepool 会在 block 执行完成之后进行 drain 操作。需要注意的是：当 block 以异常结束时，pool 不会被 drain<br>  Pool 的 drain 操作会把所有标记为 autorelease 的对象的引用计数减一，但是并不意味着这个对象一定会被释放掉，我们可以在 autorelease pool 中手动 retain 对象，以延长它的生命周期（在 MRC 中）。<br>  通过_objc_autoreleasePoolPush和_objc_autoreleasePoolPop来创建和释放自动释放池，底层是通过AutoreleasePoolPage来实现的。</li>
<li>  自动释放池是由 AutoreleasePoolPage 以双向链表的方式实现的</li>
<li>  当对象调用 autorelease 方法时，会将对象加入 AutoreleasePoolPage 的栈中</li>
<li>调用 AutoreleasePoolPage::pop 方法会向栈中的对象发送 release 消息<br>  关于自动释放池的原理，可以参考这篇文章<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/32265cbb2a26">自动释放池的前世今生</a></li>
</ul>
<h2 id="监控卡顿"><a href="#监控卡顿" class="headerlink" title="监控卡顿"></a>监控卡顿</h2><p>可以通过监控runloop的 kCFRunLoopBeforeSources和kCFRunLoopAfterWaiting的事件间隔来监控卡顿。关于卡顿监控可以参考笔者的文章<a target="_blank" rel="noopener" href="https://xiaozhuanlan.com/topic/1293805467">卡顿监控及处理</a></p>
<h2 id="创建子线程执行任务"><a href="#创建子线程执行任务" class="headerlink" title="创建子线程执行任务"></a>创建子线程执行任务</h2><p>你可以创建子线程，然后在别的线程通过performSelector:onThread:withObject:waitUntilDone:路由到该子线程进行处理。</p>
<h2 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h2><p><a target="_blank" rel="noopener" href="https://github.com/facebookarchive/AsyncDisplayKit">AsyncDisplayKit</a>( 现在更名为Texture)，是Facebook开源的用来异步绘制UI的框架。ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。<br>参考资料：<br><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a><br>苹果官方文档<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">Run Loops</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/03/Runtime%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headerimage.jpeg">
      <meta itemprop="name" content="CodeoPerryH">
      <meta itemprop="description" content="ios">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="须知少时凌云志，曾许人间第一流">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/03/Runtime%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9/" class="post-title-link" itemprop="url">Runtime</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-03 17:19:03" itemprop="dateCreated datePublished" datetime="2018-08-03T17:19:03+08:00">2018-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-27 14:29:09" itemprop="dateModified" datetime="2022-01-27T14:29:09+08:00">2022-01-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h1 id="Runtime原理"><a href="#Runtime原理" class="headerlink" title="Runtime原理"></a>Runtime原理</h1><p>Runtime是iOS核心运行机制之一，iOS App加载库、加载类、执行方法调用，全靠Runtime，这一块的知识个人认为是最基础的，基本面试必问。</p>
<h2 id="Runtime消息发送机制"><a href="#Runtime消息发送机制" class="headerlink" title="Runtime消息发送机制"></a>Runtime消息发送机制</h2><p>1）iOS调用一个方法时，实际上会调用objc_msgSend(receiver, selector, arg1, arg2, …)，该方法第一个参数是消息接收者，第二个参数是方法名，剩下的参数是方法参数；<br>2）iOS调用一个方法时，会先去该类的方法缓存列表里面查找是否有该方法，如果有直接调用，否则走第3）步；<br>3）去该类的方法列表里面找，找到直接调用，把方法加入缓存列表；否则走第4）步；<br>4）沿着该类的继承链继续查找，找到直接调用，把方法加入缓存列表；否则消息转发流程；<br><strong>很多面试者大体知道这个流程，但是有关细节不是特别清楚。</strong></p>
<ul>
<li>  问他/她objc_msgSend第一个参数、第二个参数、剩下的参数分别代表什么，不知道；</li>
<li>很多人只知道去方法列表里面查找，不知道还有个方法缓存列表。<br>  <strong>通过这些细节，可以了解一个人是否真正掌握了原理，而不是死记硬背。</strong></li>
</ul>
<h2 id="Runtime消息转发机制"><a href="#Runtime消息转发机制" class="headerlink" title="Runtime消息转发机制"></a>Runtime消息转发机制</h2><p>如果在消息发送阶段没有找到方法，iOS会走消息转发流程，流程图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/22877992-51fe635afe25ccce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>1）动态消息解析。检查是否重写了resolveInstanceMethod 方法，如果返回YES则可以通过class_addMethod 动态添加方法来处理消息，否则走第2）步；<br>2）消息target转发。forwardingTargetForSelector 用于指定哪个对象来响应消息。如果返回nil 则走第3）步；<br>3）消息转发。这步调用 methodSignatureForSelector 进行方法签名，这可以将函数的参数类型和返回值封装。如果返回 nil 执行第四步；否则返回 methodSignature，则进入 forwardInvocation ，在这里可以修改实现方法，修改响应对象等，如果方法调用成功，则结束。否则执行第4）步；<br>4）报错 unrecognized selector sent to instance。<br><strong>很多人知道这四步，但是笔者一般会问：</strong></p>
<ul>
<li>  怎么在项目里全局解决”unrecognized selector sent to instance”这类crash？本人发现很多人回答不出来，说明面试者肯定是在死记硬背，你都知道因为消息转发那三步都没处理才会报错，为什么不知道在消息转发里面处理呢？</li>
<li>  如果面试者知道可以在消息转发里面处理，防止崩溃，再问下面试者，你项目中是在哪一步处理的，看看其是否有真正实践过？</li>
</ul>
<h2 id="消息缓存机制"><a href="#消息缓存机制" class="headerlink" title="消息缓存机制"></a>消息缓存机制</h2><ul>
<li>  Runtime为每个类(不是每个类实例)缓存了一个方法列表，该方法列表采用hash表实现，hash表的优点是查找速度快，时间为O(1)。</li>
<li>父类方法的缓存只存在父类么，还是子类也会缓存父类的方法？<br>  子类会缓存父类的方法。</li>
<li>类的方法缓存大小有没有限制？<br>  在objc-cache.mm有一个变量_class_slow_grow定义如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* When _class_slow_grow is non-zero, any given cache is actually grown</span><br><span class="line"> * only on the odd-numbered times it becomes full; on the even-numbered</span><br><span class="line"> * times, it is simply emptied and re-used.  When this flag is zero,</span><br><span class="line"> * caches are grown every time. */</span><br><span class="line">static const int _class_slow_grow = 1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注释中说明，当_class_slow_grow是非0值的时候，只有当方法缓存第奇数次满（使用的槽位超过3/4）的时候，方法缓存的大小才会增长（会清空缓存，否则hash值就不对了）；当第偶数次满的时候，方法缓存会被清空并重新利用。 如果_class_slow_grow值为0，那么每一次方法缓存满的时候，其大小都会增长。<br>所以单就问题而言，答案是没有限制，虽然这个值被设置为1，方法缓存的大小增速会慢一点，但是确实是没有上限的。</p>
<ul>
<li>为什么类的方法列表不直接做成散列表呢，做成list，还要单独缓存？<br>  1、散列表是没有顺序的，Objective-C的方法列表是一个list，是有顺序的；Objective-C在查找方法的时候会顺着list依次寻找，并且category的方法在原始方法list的前面，需要先被找到，如果直接用hash存方法，方法的顺序就没法保证。<br>  2、list的方法还保存了除了selector和imp之外其他很多属性<br>  3、散列表是有空槽的，会浪费空间<br>  参考资料：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2015/08/12/deep-understanding-object-c-of-method-caching.html">深入理解 Objective-C：方法缓存</a></li>
</ul>
<h1 id="load与initialize"><a href="#load与initialize" class="headerlink" title="load与initialize"></a>load与initialize</h1><h2 id="load与initialize调用时机"><a href="#load与initialize调用时机" class="headerlink" title="load与initialize调用时机"></a>load与initialize调用时机</h2><p>+load在main函数之前被Runtime调用，+initialize 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。</p>
<h2 id="load与initialize在分类、继承链的调用顺序"><a href="#load与initialize在分类、继承链的调用顺序" class="headerlink" title="load与initialize在分类、继承链的调用顺序"></a>load与initialize在分类、继承链的调用顺序</h2><h3 id="load方法调用顺序"><a href="#load方法调用顺序" class="headerlink" title="load方法调用顺序"></a>load方法调用顺序</h3><p>父类-&gt;主类-&gt;分类</p>
<ul>
<li>  主类的 +load 方法会在它的所有父类的 +load 方法之后执行。如果主类没有实现 +load 方法，当它被runtime加载时 是不会去调用父类的 +load 方法的。</li>
<li>  分类的 +load 方法会在它的主类的 +load 方法之后执行,当一个类和它的分类都实现了 +load 方法时，两个方法都会被调用。当有多个分类时，根据编译顺序（Build Phases-&gt;Complie Sources中的顺序）依次执行。</li>
<li>在类的+load方法调用的时候，可以调用category中声明的方法么？<br>  可以调用，因为附加category到类的工作会先于+load方法的执行</li>
</ul>
<h3 id="initialize的调用顺序"><a href="#initialize的调用顺序" class="headerlink" title="initialize的调用顺序"></a>initialize的调用顺序</h3><p>+initialize 方法的调用与普通方法的调用是一样的，走的都是消息发送的流程。如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 +initialize 方法，那么就会对这个类中的实现造成覆盖。</p>
<h3 id="确保在load和initialize的调用只执行一次"><a href="#确保在load和initialize的调用只执行一次" class="headerlink" title="确保在load和initialize的调用只执行一次"></a>确保在load和initialize的调用只执行一次</h3><p>由于initialize可能会调用多次，所以在这两个方法里面做的初始化操作需要保证只初始化一次，用dispatch_once来控制</p>
<h1 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h1><p>OC不像C++等高级语言能直接继承多个类，不过OC可以使用类别和协议来实现多继承。</p>
<h2 id="类别加载时机"><a href="#类别加载时机" class="headerlink" title="类别加载时机"></a>类别加载时机</h2><ul>
<li>  在App加载时，Runtime会把Category的实例方法、协议以及属性添加到类上；把Category的类方法添加到类的metaclass上。</li>
<li>  category的方法没有“完全替换掉”原来类已经有的方法，如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA。</li>
<li>  category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会停止查找，殊不知后面可能还有一样名字的方法。</li>
</ul>
<h2 id="类别和扩展区别"><a href="#类别和扩展区别" class="headerlink" title="类别和扩展区别"></a>类别和扩展区别</h2><ul>
<li>  extension在编译期决议，它是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。</li>
<li>  但是category则完全不一样，它是在运行期决议的。 就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。</li>
<li>  category附加到类的工作会先于+load方法的执行。</li>
</ul>
<h2 id="类别添加属性、方法"><a href="#类别添加属性、方法" class="headerlink" title="类别添加属性、方法"></a>类别添加属性、方法</h2><ul>
<li>  在类别中不能直接以@property的方式定义属性，OC不会主动给类别属性生成setter和getter方法；需要通过objc_setAssociatedObject来实现。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@interface TestClass(ak)</span><br><span class="line"></span><br><span class="line">@property(nonatomic,copy) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation TestClass (ak)</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name&#123;</span><br><span class="line"></span><br><span class="line">    objc_setAssociatedObject(self,  @selector(name), name, OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString*)name&#123;</span><br><span class="line">    NSString *nameObject = objc_getAssociatedObject(self,  @selector(name));</span><br><span class="line">    return nameObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  objc_setAssociatedObject key的定义用@selector(属性名)这样能保证key的唯一。</li>
<li>关联对象都由AssociationsManager管理。AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。<br>  runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作</li>
</ul>
<h2 id="类别同名方法覆盖问题"><a href="#类别同名方法覆盖问题" class="headerlink" title="类别同名方法覆盖问题"></a>类别同名方法覆盖问题</h2><ul>
<li>  如果类别和主类都有名叫funA的方法，那么在类别加载完成之后，类的方法列表里会有两个funA；</li>
<li>  类别的方法被放到了新方法列表的前面，而主类的方法被放到了新方法列表的后面，这就造成了类别方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会停止查找；</li>
<li>  如果多个类别定义了同名方法funA,具体调用哪个类别的实现由编译顺序决定（Build Phases-&gt;Complie Sources中的顺序），后编译的类别的实现将被调用。</li>
<li>  在日常开发过程中，类别方法重名轻则造成调用不正确，重则造成crash，我们可以通过给类别方法名加前缀避免方法重名。</li>
</ul>
<h2 id="怎么调用被覆盖掉的方法"><a href="#怎么调用被覆盖掉的方法" class="headerlink" title="怎么调用被覆盖掉的方法"></a>怎么调用被覆盖掉的方法</h2><p>category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Class currentClass = [TestClass class];</span><br><span class="line">TestClass *my = [[TestClass alloc] init];</span><br><span class="line"></span><br><span class="line">if (currentClass) &#123;</span><br><span class="line">    unsigned int methodCount;</span><br><span class="line">    Method *methodList = class_copyMethodList(currentClass, &amp;methodCount);</span><br><span class="line">    IMP lastImp = NULL;</span><br><span class="line">    SEL lastSel = NULL;</span><br><span class="line">    for (NSInteger i = 0; i &lt; methodCount; i++) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) </span><br><span class="line">                                        encoding:NSUTF8StringEncoding];</span><br><span class="line">        if ([@&quot;printName&quot; isEqualToString:methodName]) &#123;</span><br><span class="line">            lastImp = method_getImplementation(method);</span><br><span class="line">            lastSel = method_getName(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    typedef void (*fn)(id,SEL);</span><br><span class="line"></span><br><span class="line">    if (lastImp != NULL) &#123;</span><br><span class="line">        fn f = (fn)lastImp;</span><br><span class="line">        f(my, lastSel);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于类别更深入的解析可以参见美团的技术文章<a target="_blank" rel="noopener" href="https://tech.meituan.com/2015/03/03/diveintocategory.html">深入理解Objective-C：Category</a></p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>iOS中的协议类似于Java、C++中的接口类，协议在OC中可以用来实现多继承和代理。</p>
<h2 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h2><p>协议中的方法可以声明为@required（要求实现，如果没有实现，会发出警告，但编译不报错）或者@optional（不要求实现，不实现也不会有警告）。如果不声明，默认为@required。<br>笔者经常会问面试者如下两个问题：<br>-怎么判断一个类是否实现了某个协议？很多人不知道可以通过conformsToProtocol来判断。<br>-假如你要求业务方实现一个delegate，你怎么判断业务方有没有实现dalegate的某个方法？很多人不知道可以通过respondsToSelector来判断。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Class的定义"><a href="#Class的定义" class="headerlink" title="Class的定义"></a>Class的定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">在oc中打开objc.h</span><br><span class="line"></span><br><span class="line">typedef struct objc_class *Class;     //Class是指向结构体objc_class的指针</span><br><span class="line"></span><br><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY; //isa，代表的是该类类对象</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE; //父类</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE; //类名</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE; </span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE; //对象大小</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE; //成员变量列表</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE; //实例方法列表</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE; //方法缓存列表（是个hash表），用来消息发送时候，快速查找方法</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE; //类实现协议列表</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line">/* Use `Class` instead of `struct objc_class *` */</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="怎么枚举一个类的方法列表？"><a href="#怎么枚举一个类的方法列表？" class="headerlink" title="怎么枚举一个类的方法列表？"></a>怎么枚举一个类的方法列表？</h2><p>class_copyMethodList</p>
<h2 id="怎么枚举一个类的属性列表？"><a href="#怎么枚举一个类的属性列表？" class="headerlink" title="怎么枚举一个类的属性列表？"></a>怎么枚举一个类的属性列表？</h2><p>class_copyPropertyList</p>
<h2 id="怎么枚举一个类的成员变量列表？"><a href="#怎么枚举一个类的成员变量列表？" class="headerlink" title="怎么枚举一个类的成员变量列表？"></a>怎么枚举一个类的成员变量列表？</h2><p>class_copyIvarList</p>
<h2 id="怎么枚举一个类实现的协议列表？"><a href="#怎么枚举一个类实现的协议列表？" class="headerlink" title="怎么枚举一个类实现的协议列表？"></a>怎么枚举一个类实现的协议列表？</h2><p>class_copyProtocolList</p>
<h1 id="id和instancetype的区别"><a href="#id和instancetype的区别" class="headerlink" title="id和instancetype的区别"></a>id和instancetype的区别</h1><ul>
<li>  id能用做返回值、参数。instancetype只能用做返回值。</li>
<li>  instancetype是类型相关的，如果把一个instancetype的对象赋值给另外类，编译器会警告。id不会。</li>
</ul>
<h2 id="Runtime开源代码"><a href="#Runtime开源代码" class="headerlink" title="Runtime开源代码"></a>Runtime开源代码</h2><p>runtime是开源的，可以在<a target="_blank" rel="noopener" href="https://github.com/opensource-apple/objc4">Apple Github</a>和<a target="_blank" rel="noopener" href="https://github.com/opensource-apple/objc4">Apple OpenSource</a>下载来阅读。<br>参考资料：<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3e050ec3b759">Objective-C中的Runtime</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/02/MVC%E3%80%81MVVM%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headerimage.jpeg">
      <meta itemprop="name" content="CodeoPerryH">
      <meta itemprop="description" content="ios">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="须知少时凌云志，曾许人间第一流">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/02/MVC%E3%80%81MVVM%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9/" class="post-title-link" itemprop="url">框架MVC&MVVM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-02 17:19:03" itemprop="dateCreated datePublished" datetime="2018-08-02T17:19:03+08:00">2018-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-27 14:28:59" itemprop="dateModified" datetime="2022-01-27T14:28:59+08:00">2022-01-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>MVC</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>MVC模式（Model–View–Controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。<br>在iOS中，MVC通信模式如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/22877992-2110caa320a00a75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li>  VC持有Model和View，Model和View不直接交互。</li>
<li>  当用户点击View时，通知VC，需要更新Model时由VC来更新Model。</li>
<li>  当Model发生变化时候，利用KVO等技术通知VC，由VC来更新View。</li>
</ul>
<h2 id="Massive-ViewController"><a href="#Massive-ViewController" class="headerlink" title="Massive ViewController"></a>Massive ViewController</h2><p>如果我们把所有的业务逻辑都写在VC里面，不做好拆分，很容易造成VC臃肿。这个时候需要为VC瘦身，而MVVM就是为了解决VC过于庞大引入的设计模式。</p>
<h2 id="怎么为VC瘦身"><a href="#怎么为VC瘦身" class="headerlink" title="怎么为VC瘦身"></a>怎么为VC瘦身</h2><p>1、一个干净的VC应该只做如下事：</p>
<ul>
<li>  在初始化时，构造相应的 View 和 Model。</li>
<li>  监听 Model 层的事件，将 Model 层的数据传递到 View 层。</li>
<li>  监听 View 层的事件，并且将 View 层的事件转发到 Model 层。</li>
<li>  其他的事情可以由若干个Manager来完成。</li>
</ul>
<p>2、那么在iOS中，我们有那些常用的瘦身手段呢？</p>
<ul>
<li>  网络层。定义网络请求类 ，一个网络请求代表一个类。网络请求类负责发网络请求以及把响应数据解析为model，model以及response通过block方式回调给调用方。这里的调用方大部分时候是VC。</li>
<li>  数据存储层。定义数据存储Manager，用来加载数据和缓存数据。</li>
<li>  定义数据转换层。负责数据转换，比如Model跟View Model的转换。</li>
<li>  可以通过类别的方式给VC做好功能的划分，比如定义TableView分类用来处理UITableViewDelegate &amp;&amp; UITableViewDataSource代理方法；定义Network分类用来处理网络逻辑。</li>
</ul>
<p>推荐大家每个业务模块至少建立Model、View、VC、Network、Cache五个文件夹来分类代码，并且遵循上面原则来给VC瘦身。</p>
<h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><img src="https://upload-images.jianshu.io/upload_images/22877992-b16875587e6e47c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li>  View、VC可以持有View Model，反之不行；View Model可以持有Model，反之不行。 View Model相当于MVC中的VC作用，用来连接View、VC 和Model。</li>
<li>  当Model更新时，通知View Model，View Model再通知VC或者View，来更新View；</li>
<li>  当用户点击View时候，通知View Model，View Model通知Model来更新Model。</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>实现MVVM的关键是如何做数据通知，在iOS中可以用KVO来实现。业内一般用ReactiveCocoa来实现数据绑定及通知。</p>
<h1 id="选择MVC还是MVVM？"><a href="#选择MVC还是MVVM？" class="headerlink" title="选择MVC还是MVVM？"></a>选择MVC还是MVVM？</h1><p>无论是MVC还是MVVM，我们的本质都是想对VC进行瘦身。<br>用MVVM的话，分层更加清晰，不过要引入ReactiveCocoa，ReactiveCocoa比较重，学习成本比较高，最重要的是用的是block，调试起来比较麻烦，目前业内用得不是特别多。<br>笔者推荐用MVC，按照上面介绍的VC瘦身方案来使用，这样轻量点。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/01/KVC&KVO%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headerimage.jpeg">
      <meta itemprop="name" content="CodeoPerryH">
      <meta itemprop="description" content="ios">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="须知少时凌云志，曾许人间第一流">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/01/KVC&KVO%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9/" class="post-title-link" itemprop="url">KVC&KVO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-01 17:19:03" itemprop="dateCreated datePublished" datetime="2018-08-01T17:19:03+08:00">2018-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-27 14:28:54" itemprop="dateModified" datetime="2022-01-27T14:28:54+08:00">2022-01-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>
# KVC

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>  KVC 是 Key-Value-Coding 的简称。</li>
<li>  KVC 是一种可以直接通过字符串的名字 key 来访问类属性的机制，而不需要调用setter、getter方法去访问。</li>
<li>  我们可以通过在运行时动态的访问和修改对象的属性。KVC 是 iOS 开发中的黑魔法之一。</li>
</ul>
<h2 id="设置值-amp-amp-获取值"><a href="#设置值-amp-amp-获取值" class="headerlink" title="设置值&amp;&amp;获取值"></a>设置值&amp;&amp;获取值</h2><ul>
<li>  设置值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(id)value forKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;</span><br><span class="line"></span><br><span class="line">// 它的默认实现是抛出异常，可以重写这个函数啥也不做来防止崩溃。</span><br><span class="line">- (void)setValue:(id)value forUndefinedKey:(NSString *)key;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  获取值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)valueForKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">- (id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line"></span><br><span class="line">// 如果key不存在，且KVC无法搜索到任何和key有关的字段或者属性，则会调用这个方法，默认实现抛出异常。可以通过重写该方法返回nil来防止崩溃</span><br><span class="line">- (id)valueForUndefinedKey:(NSString *)key;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="KVC设置和查找顺序"><a href="#KVC设置和查找顺序" class="headerlink" title="KVC设置和查找顺序"></a>KVC设置和查找顺序</h2><ul>
<li>设置顺序<br>  调用- (void)setValue:(id)value forKey:(NSString *)key;时，执行操作<br>  1、首先搜索setter方法，有就直接赋值。<br>  2、如果1中的 setter 方法没有找到，再检查类方法+ (BOOL)accessInstanceVariablesDirectly<br>  返回 NO，则执行setValue:forUndefinedKey:<br>  返回 YES，则按_key，_isKey，key，isKey的顺序搜索成员名进行赋值。<br>  3、还没有找到的话，就调用setValue:forUndefinedKey:</li>
<li>查找顺序<br>  当调用valueForKey:@”key”的代码时，KVC对key的搜索方式不同于setValue”akon” forKey:@”key”，其搜索方式如下：</li>
</ul>
<p>1、首先按get, is的顺序查找getter方法，找到的话会直接调用。如果是BOOL或者Int等值类型，会将其包装成一个NSNumber对象。<br>2、如果没有找到，KVC则会查找countOf、objectInAtIndex或AtIndexes格式的方法。如果countOf方法和另外两个方法中的一个被找到，那么就会返回一个可以响应NSArray所有方法的代理集合(它是NSKeyValueArray，是NSArray的子类)，调<br>用这个代理集合的方法，就会以countOf,objectInAtIndex或AtIndexes这几个方法组合的形式调用。还有一个可选的get:range:方法。所以你想重新定义KVC的一些功能，你可以添加这些方法，需要注意的是你的方法名要符合KVC的标准命名方法，包括方法签名。<br>3、如果上面的方法没有找到，那么会同时查找countOf，enumeratorOf,memberOf格式的方法。如果这三个方法都找到，那么就返回一个可以响应NSSet所的方法的代理集合，和上面一样，给这个代理集合发NSSet的消息，就会以countOf，enumeratorOf,memberOf组合的形式调用。<br>4、如果还没有找到，再检查类方法+ (BOOL)accessInstanceVariablesDirectly,如果返回YES(默认行为)，那么和先前的设值一样，会按_key,_isKey,key,isKey的顺序搜索成员变量名。<br>如果还没找到，直接调用该对象的valueForUndefinedKey:方法，该方法默认是抛出异常。</p>
<h2 id="KVC防崩溃"><a href="#KVC防崩溃" class="headerlink" title="KVC防崩溃"></a>KVC防崩溃</h2><p>我们经常会使用KVC来设置属性和获取属性，但是如果对象没有按照KVC的规则声明该属性，则会造成crash，怎么全局通用地防止这类崩溃呢？<br>可以通过写一个NSObject分类来防崩溃。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject(AKPreventKVCCrash)</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@ implementation NSObject(AKPreventKVCCrash)</span><br><span class="line"></span><br><span class="line">- (id)valueForUndefinedKey:(NSString *)key&#123;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setNilValueForKey:(NSString *)key&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setValue:(id)value forUndefinedKey:(NSString *)key&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>KVO即Key-Value Observing，翻译成键值观察。它是一种观察者模式的衍生。其基本思想是，对目标对象的某属性添加观察，当该属性发生变化时，通过触发观察者对象实现的KVO接口方法，来自动的通知观察者。</p>
<h2 id="注册、移除KVO"><a href="#注册、移除KVO" class="headerlink" title="注册、移除KVO"></a>注册、移除KVO</h2><p>通过如下两个方案来注册、移除KVO</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context;</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过observeValueForKeyPath来获取值的变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">                      ofObject:(id)object</span><br><span class="line">                        change:(NSDictionary *)change</span><br><span class="line">                       context:(void *)context</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以通过facebook开源库<a target="_blank" rel="noopener" href="https://github.com/facebook/KVOController">KVOController</a>方便地进行KVO。</p>
<h2 id="手动KVO"><a href="#手动KVO" class="headerlink" title="手动KVO"></a>手动KVO</h2><p>当我们调用addObserver KVO了一个对象的属性后，当对象的属性发生变化时，iOS会自动调用观察者的observeValueForKeyPath方法。有的时候，我们可能要在setter方法中插入一些代码，然后进行手动KVO，怎么实现呢？<br>通过重写类的automaticallyNotifiesObserversForKey方法，指定对应属性不要自动KOV，然后在setter方法里面手动调用willChangeValueForKey和didChangeValueForKey来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface ClassA: NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassA</span><br><span class="line"></span><br><span class="line">// for manual KVO - age</span><br><span class="line">- (void)setAge:(int)theAge&#123;</span><br><span class="line"></span><br><span class="line">    [self willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">    _age = theAge;</span><br><span class="line">    [self didChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL) automaticallyNotifiesObserversForKey:(NSString *)key &#123;</span><br><span class="line"></span><br><span class="line">    if ([key isEqualToString:@&quot;age&quot;]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [super automaticallyNotifiesObserversForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="KVO和线程"><a href="#KVO和线程" class="headerlink" title="KVO和线程"></a>KVO和线程</h2><p>KVO是同步调用，调用线程跟属性值改变的线程是相同的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.age = 10;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>KVO 能保证所有age的观察者在 setter 方法返回前被通知到。</p>
<h2 id="KVO实现原理"><a href="#KVO实现原理" class="headerlink" title="KVO实现原理"></a>KVO实现原理</h2><p>苹果<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html#//apple_ref/doc/uid/20002307-BAJEAIEE">官方文档</a>对KVO的实现原理描述如下：</p>
<blockquote>
<p>Key-Value Observing Implementation Details<br>Automatic key-value observing is implemented using a technique called isa-swizzling.<br>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.<br>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.<br>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p>
</blockquote>
<p>KVO的实现采用了 isa-swizzling技术。当一个类型为ClassA 的对象，被添加了观察后，系统会生成一个派生类 NSKVONotifying_ClassA 类，并将对象的isa指针指向NSKVONotifying_ClassA，也就是说这个对象的类型发生了变化。因此在向ClassA对象发送消息时候，实际上是发送到了NSKVONotifying_ClassA的方法。由于编译器对NSKVONotifying_ClassA的方法进行了 override，并添加了通知代码，因此会向注册的对象发送通知。注意派生类只重写注册了观察者的属性方法。<br>派生类会重写setter、class、delloc、_isKVOA</p>
<h3 id="重写Setter"><a href="#重写Setter" class="headerlink" title="重写Setter"></a>重写Setter</h3><p>在 setter 中，会添加以下两个方法的调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)willChangeValueForKey:(NSString *)key;</span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在 didChangeValueForKey: 中，去调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath</span><br><span class="line">                      ofObject:(nullable id)object</span><br><span class="line">                        change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change</span><br><span class="line">                       context:(nullable void *)context;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>包含了新值和旧值的通知。于是实现了属性值修改的通知。<br>因为 KVO 的原理是修改 setter 方法，因此使用 KVO 必须调用 setter 。若直接访问属性对象则没有效果。</p>
<h3 id="重写class"><a href="#重写class" class="headerlink" title="重写class"></a>重写class</h3><p>下面代码展示了对ClassA对象objA添加KVO后，objA的isa指针指向了NSKVONotifying_ClassA。<br>注意：[objA class]返回的是objA真正所属的类。object_getClass(objA)返回的objA的isa指针所属的类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@interface ClassA: NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) NSInteger age;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassA</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface ClassB: NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassB</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%@&quot;, change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    // Override point for customization after application launch.</span><br><span class="line"></span><br><span class="line">    ClassA* objA = [[ClassA alloc] init];</span><br><span class="line">    ClassB* objB = [[ClassB alloc] init];</span><br><span class="line"></span><br><span class="line">    [objA addObserver:objB forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%@&quot;, [objA class]); //输出ClassA</span><br><span class="line">    NSLog(@&quot;%@&quot;, object_getClass(objA));  //输出NSKVONotifying_ClassA（object_getClass方法返回isa指向）</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="重写delloc"><a href="#重写delloc" class="headerlink" title="重写delloc"></a>重写delloc</h3><p>观察移除后使class变回去观察前的类(通过isa指向)。比如上例的ClassA</p>
<h3 id="重写-isKVOA"><a href="#重写-isKVOA" class="headerlink" title="重写_isKVOA"></a>重写_isKVOA</h3><p>判断被观察者自己是否同时也观察了其他对象。<br>参考资料：<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903602545229831#heading-9">iOS KVC和KVO详解</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/66bda10168f1">KVC和KVO的使用及原理</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CodeoPerryH"
      src="/images/headerimage.jpeg">
  <p class="site-author-name" itemprop="name">CodeoPerryH</p>
  <div class="site-description" itemprop="description">ios</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CodeoPerryH</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
